## 137.Single Number II

## 题目描述

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例 1:**

```
输入: [2,2,3,2]
输出: 3
```

**示例 2:**

```
输入: [0,1,0,1,0,1,99]
输出: 99
```



### 解答1

​	暴力搜索，和上一道题一样。

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        暴力搜索
        for i in range(len(nums)):
            if nums[i] not in nums[:i]+nums[i+1:]:
                return nums[i]
```

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$ 



### 解答2

​	使用字典存储各个元素以及出现的次数，最后遍历字典得出结果。

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:        
    	d = {}
        
        for num in nums:
            d[num] = d.get(num,0) + 1
        for key, value in d.items():
            if value==1:
                return k
```

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解答3

​	第三种真的可以说是技巧性很高了，参考一下就好。

​	举例[1,1,1,2] 他们转换成二进制就是[01,01,01,10],我们可以知道第一位(从右往左)的二进制总共出现了三次1,那么我们的目标结果在第一位就绝对不会是1,相对的第二位出现了一次1,那么我们的目标值在这一位就是1。

​	a为高位,b为低位.两个一起表示一个两位二进制表示的数字(一个计数器)。

| 计数器 | a | b | 出现次数 |
| :--------------: | :----------: | :--------------: |     |
| 0          | 0    | 0 | 0 |
| 1 | 0      | 1        | 1 |
| 2 | 1 | 0 | 2 |
| 0 | 0 | 0 | 3 |
| 1 | 0 | 1 | 4 |



​	上面是我们计数器需要达成的目标,一个计数循环.我们再进一步. 我们遍历数据,每来一个数据c(这里一个二进制)我们的a与b就要开始为c计数,那么有以下情况。
| a | b | c | 结果a | 结果b |
| :--------------: | :----------: | :--------------: |     |     |
| 0          | 0    | 0 | 0 | 0 |
| 0 | 1      | 0       | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |

上面比较容易明白,来的是0,那么我们不统计,原来a,b的统计结果不变

|  a   |  b   |  c   | 结果a | 结果b |
| :--: | :--: | :--: | ----- | ----- |
|  0   |  0   |  1   | 0     | 1     |
|  0   |  1   |  1   | 1     | 0     |
|  1   |  0   |  1   | 0     | 0     |

​	这里也比较容易明白,当来的是1,那么只要为其计数增加1就好.接下来就是我们的重头戏了.开始设计逻辑门能让我们的计数器保持3个状态记录循环.
	我们观察结果a,可以看到会使结果a=1的状态仅有 ( a为1 && b为0 && c为0 ) || (a为0 && b为1 && c为1),同理可以推出b的表达式.故可得出公式结果a结果b的表达式:

+ 结果a = (a & ~b & ~c) + (~a & b & c)

+ 结果b = (~a & ~b & c) + (~a & b & ~c)

  可以再化简一下:

+ 结果b = (b ^ c) & -a

+ 结果a = (a ^ c) & -b



```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:        
        a = 0
        b = 0
        for num in nums:
            b = (b ^ num) & -a
            a = (a ^ num) & -b
        return b
```

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

