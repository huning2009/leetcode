## 010 Regular Expression Matching

### 题目描述

给定一个字符串 (`s`) 和一个字符模式 (`p`)。实现支持 `'.'` 和 `'*'` 的正则表达式匹配。

```
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
```

匹配应该覆盖**整个**字符串 (`s`) ，而不是部分字符串。

**说明:**

- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。

**示例 1:**

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。
```

**示例 3:**

```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
```

**示例 4:**

```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
```

**示例 5:**

```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```



### 解答

​	这道题比较难，如果采用硬匹配的方式是比较难做出来的，由于某一位置是否能匹配可以由前面位置能否匹配来决定，所以很容易可以想到使用动态规划来解题。

​	首先定义dp数组， $dp[i][j]$表示输入串长度为i,模式串长度为j时，是否能匹配，其实动态规划最难得一步就是定义状态数组了，然后去寻找动态规划三要素(边界，初始状态，转移方程)。

+ 初始状态：输入串为空，模式串为空：$dp[0][0]$=1
+ 边界条件：
  + 输入串为空，模式串不为空，此时假如可以匹配，那必然是出现\*了在模式串中，这样它可以匹配０个前面的字符，所以此时条件为：$p[j-1]=='*' \ and\ dp[0][j-2] $。
  + 输入串不为空，模式串为空，那必然不能匹配。
+ 转移方程，转移方程依也就是利用之前的值来求当前的dp\[i][j]，但是这里是需要分情况分讨论的由于现在已经知道两个边界的值，所以只需要讨论大于１的情况：
  + 假如p[j - 1] == s[i - 1] or p[j - 1] == '.' ，此时可以将当前的字符匹配掉，因此dp\[i][j]=dp\[i-1][j-1]。
  + 假如p[j - 1] =='\*'，因为\*可以匹配０个或者多个它的上个字符(这里要注意了，也就表示*是不能单独出现的)，这时候就需要利用前面的信息了：
    + 假如p[j - 2] != '.' and p[j - 2] != s[i - 1]，这说明上个字符既不是‘.’，也不能和输入串的当前字符匹配，所以*只能匹配０个上个字符：dp\[i][j] = dp\[i][j-2]
    + 假如不在上个条件里，说明是可以匹配的，那么*可以匹配０个、１个或者多个上个字符：dp\[i][j] = dp\[i][j-1] or dp\[i-1][j] or dp\[i][j-2]
  + 其他情况就是０了。



```python
class Solution:
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        # 使用动态规划
        # dp[i][j]表示输入串长度为i,模式串长度为j时，是否能匹配
        dp = [[0 for i in range(len(p) + 1)] for j in range(len(s) + 1)]
        # 初始状态
        dp[0][0] = 1

        for j in range(1, len(p) + 1):
            if p[j - 1] == '*' and dp[0][j - 2]:
                dp[0][j] = 1

        for i in range(1, len(s) + 1):
            for j in range(1, len(p) + 1):
                if p[j - 1] == s[i - 1] or p[j - 1] == '.':
                    dp[i][j] = dp[i - 1][j - 1]

                elif p[j - 1] == '*':
                    if p[j - 2] != '.' and p[j - 2] != s[i - 1]:
                        dp[i][j] = dp[i][j - 2]
                    else:
                        print(dp[i - 1][j], dp[i][j - 1], dp[i][j - 2])
                        dp[i][j] = dp[i - 1][j] or dp[i][j - 1] or dp[i][j - 2]
        return dp[len(s)][len(p)] == 1
```

复杂度分析：

- 时间复杂度：$O(n*m)$
- 空间复杂度：$O(n*m)$

