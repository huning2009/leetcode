## 862.Shortest Subarray with Sum at Least K

## 题目描述

返回 A 的最短的非空连续子数组的长度，该子数组的和至少为 K 。

如果没有和至少为 K 的非空子数组，返回 -1 。

 

**示例 1：**

```
输入：A = [1], K = 1
输出：1
```

**示例 2：**

```
输入：A = [1,2], K = 4
输出：-1
```

**示例 3：**

```
输入：A = [2,-1,2], K = 3
输出：3
```

**提示：**

1. 1 <= A.length <= 50000
2. -10 ^ 5 <= A[i] <= 10 ^ 5
3. 1 <= K <= 10 ^ 9



### 解答

​	这道题其实综合了几道题的思路，有贪心、滑动窗口，首先就是遍历，假如当前和小于0，直接从下一个开始加和，假如窗口内的和已经满足了大于等于K，那么就把窗口的左侧往前移动，直到窗口最小，但是这样有些测试用例是过不了的，比如[84,-37,32,40,95]　167这种情况，得到的最大长度为5，但是实际上最后三个数字就可以满足，这是因为出现了负数，可以和前面的正数抵消，但是在移动窗口的左侧的时候减去84立马就不满足了，所以需要在移动之前做一些处理，怎么做呢？这里参考了disscuss的解答，非常巧妙，假如遍历到了负数那我直接把这个负数的值加到上一个数上，把此数置为0，这样不就可以为后面的窗口做一部分抵消，假如还为负数那么一直往前加，这样在移动窗口左端的时候就可以考虑到负数的影响。



```python
class Solution:
    def shortestSubarray(self, A: List[int], K: int) -> int:
        sums = 0
        start = 0
        res = -1
        for i in range(len(A)):
            if A[i]>K:
                return 1
            sums+=A[i]
            # 贪心的思想
            if sums<1:
                sums = 0
                start = i+1
                continue
            # 负数可以抵消一部分正数　比如[84,-37,32,40,95]　167这种情况
            j = i
            while A[j] < 0:
                A[j-1] = A[j]+A[j-1]
                A[j] = 0
                j-=1
            if sums>=K:
                while sums>=K:
                    sums-=A[start]
                    start+=1
                # print(start,i)
                if res<0 or i-start+2<res:
                    res = i-start+2
        return res
```

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$ 