## 343.Integer Break

## 题目描述

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

**示例 1:**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```



说明: 你可以假设 n 不小于 2 且不大于 58。



### 解答1

​	其实可以从示例看出规律，一个数字拆分成两个数字使它们的乘积最大化，那么肯定是分成两个相等的数字，若是奇数，那就是连续的两个数，这么递归下去就是最后分成了m个3和n个2，那么m和n等于多少呢，其实也是很直观的，2肯定不如3乘起来大，所以尽可能分多的3，但是这里也有一个界限就是4肯定不能分成3+1而要分成2+2。

```python
class Solution(object):
    def integerBreak(self, n):
        """
        :type n: int
        :rtype: int
        """
        # 尽可能多的分成3和2，如果够最后必须留2个2而不是3+1
        if n<=3:
            return n-1
        res = 1
        while n>4:
            res*=3
            n-=3
        res*=n
        return res
```



### 解答2

​	使用动态规划解题，dp[i]表示i分割后的最大乘积，那么对于i，可以遍历i之前的所有位置j，找到最大的`dp[i-j]*j`即可，但是这里也要考虑没有分割的情况，因为dp是分割后的最大乘积，他并没有包括不分割的情况`(i-j)*j`。

```python
class Solution(object):
    def integerBreak(self, n):
        """
        :type n: int
        :rtype: int
        """

        # 动态规划 dp[i]表示i分割后的最大乘积
        dp = [1]*(n+1)
        for i in range(2,n+1):
            for j in range(i-1,1,-1):
                # dp是分割后的最大乘积，他并没有包括不分割的情况(i-j)*j
                dp[i] = max(dp[i],max(dp[i-j]*j,(i-j)*j))
        return dp[n]
```

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(n)$ 