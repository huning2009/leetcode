## 260.Single Number III

## 题目描述

给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

**示例 :**

```
输入: [1,2,1,3,2,5]
输出: [3,5]
```

**注意：**

1. 结果输出的顺序并不重要，对于上面的例子， `[5, 3]` 也是正确答案。
2. 你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？



### 解答

​	这道题要找到只出现一次的那两个元素，假如只有一个元素只出现一遍，那么我们直接使用异或运算把所有的数字异或就能得到结果，但是这里有两个数字都只出现了一遍，假如把所有的数字做异或运算，最后的结果就是这两个数字a，b的异或结果，若可以把所有的数字分成两个组，a和b分别在不同的组，那么结果就能得到，怎么分开是关键。

​	我们知道数组所有元素异或运算（也就是x，y的异或运算）sum的结果一定不为0，因为x≠y，那么x和y的二进制表示中肯定有一或多位不相等，即肯定存在x中的某一位值为 1 ， y中相同位的值为 0 。我们依据x和y中某一位值不一样将数组分为两组：分组一包含x，也就是某特定位为1（0）的所有元素，分组二包含y，也就是某特定位为0（1）的所有元素。

​	可以用与&运算去判断数组中某位的值是0还是1。我们引入一个flag值，flag表示的是x，y的二进制表示中，值不同的一位，将这一位取值为1，其它所有位取值为0（如果还存在其它取值不同的位，也置为0）。这里我们确定flag值的方法 ：  flag = sum & (~(sum - 1));

```
举个例子，比如 x = 5，y = 3： 

首先转换二进制 x = 101 y = 11     ——>    异或运算  sum = x ^ y = 110    ——>    flag取值 flag = 10 （010）
```

​	找到了flag然后可以用与&运算了，x，y中肯定有一个数字同flag做与&运算时取值为0。为啥，因为flag为0的位，无论同1还是0做与运算都位0，那么flag为1的位只有一位，而这位是根据x，y不同位确定的位数，也就是说x，y同flag为1位相同的位数，一个是0，另一个是1，是0的那个数做与运算当然结果为0了。 其它数也根据是根据这个道理，进行了分组。最后将分组一内所有的元素做异或运算，得出x，将分组二内所有元素做异或运算，得出y。为啥，因为啊分组一（二）中的数，除去x和y以外，都是相同的数字。

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        res = [0,0]
        sums = nums[0]
        
        for i in range(1,len(nums)):
            sums ^= nums[i]
        flag = sums&(~(sums-1))
        for num in nums:
            if flag&num==0:
                res[0] ^= num
            else:
                res[1] ^= num
        return res
```

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$ 

