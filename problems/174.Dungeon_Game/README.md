## 174.Dungeon Game

## 题目描述

一些恶魔抓住了公主（**P**）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（**K**）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为*负整数*，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 *0*），要么包含增加骑士健康点数的魔法球（若房间里的值为*正整数*，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

 

**编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。**

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 `右 -> 右 -> 下 -> 下`，则骑士的初始健康点数至少为 **7**。

| -2 (K) | -3   | 3      |
| ------ | ---- | ------ |
| -5     | -10  | 1      |
| 10     | 30   | -5 (P) |

 

**说明:**

- 骑士的健康点数没有上限。
- 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。



### 解答

​	这道题一看就是得用动态规划来解题，但是这个状态和转移过程跟之前的定义是不一样的，动态规划的特点在于用已知来推未知，状态转化的方式是固定的，这个方向就是从未知的结果->已知结果 推导的方向，那么这道题如果从前往后是不可行的，所以需要从后往前，我们定义状态是进入每个格子时最少需要的血量，那么我们现在就知道到达最后时，最少需要的血量为:max(1-dungeon\[m-1][n-1], 1)，也就是说最后最少剩一滴血，那么进入这个格子时剩的血加上这个格子的值必须大于1。这样反向去推就很清楚了，转移时取右边和下面最小的。

```python
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        # 使用动态规划 dp[i][j]表示进入这个点骑士的最小健康点数 使用倒推
        dp = [[0]*len(dungeon[0]) for i in range(len(dungeon))]
        m = len(dungeon)
        n = len(dungeon[0])
        dp[m-1][n-1] = max(1-dungeon[m-1][n-1], 1)
        
        
        # 边界
        for i in range(m-2,-1,-1):
            dp[i][n-1] = max(dp[i+1][n-1] - dungeon[i][n-1],1)
            
        for j in range(n-2,-1,-1):
            dp[m-1][j] = max(dp[m-1][j+1] - dungeon[m-1][j],1)
        # print(dp)
        for i in range(m-2,-1,-1):
             for j in range(n-2,-1,-1):
                    right = max(dp[i][j+1] - dungeon[i][j],1)
                    down = max(dp[i+1][j] - dungeon[i][j],1)
                    dp[i][j] = min(right,down)
        #  print(dp)
        return dp[0][0]
```

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(n^2)$

