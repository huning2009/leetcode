## 375.Guess Number Higher or Lower II

### 题目描述

我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。

每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。

然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。

**示例:**

```
n = 10, 我选择了8.

第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。
第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。
第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。

游戏结束。8 就是我选的数字。

你最终要支付 5 + 7 + 9 = 21 块钱。
```

给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。



### 解答

​	一开始还是以为使用二分查找去猜，但是这道题并没有给要猜的数字呀，题目只给了一个n，要计算的是至少需要拥有多少现金才能确保你能赢得这个游戏，也就是要猜中任意数字需要的最小金额，这也算一个经典的动态规划题目了。

​	用dp\[j][i]表示j-i中猜出**任一**数字所需要的最少金额，那么我们需要遍历每一段区间[j,  i]，维护一个全局最小值global_min变量，然后遍历该区间中的每一个数字，计算局部最大值local_max = k +  max(dp\[j][k - 1], dp\[k +  1][i])，这个正好是将该区间在每一个位置都分为两段，然后取当前位置的花费加上左右两段中较大的花费之和为局部最大值，为啥要取两者之间的较大值呢，因为我们要cover所有的情况，求出最少需要多少钱，就得取最坏的情况。

```
举例：
如果有三个数字1，2，3，那么我们就先猜2，根据对方的反馈，就可以确定正确的数字，所以我们的cost最低为2。

如果有四个数字1，2，3，4，我们的策略是用k来遍历所有的数字，然后再根据k分成的左右两个区间，取其中的较大cost加上k。

当k为1时，左区间为空，所以cost为0，而右区间2，3，4，根据之前的分析应该取3，所以整个cost就是1+3=4。

当k为2时，左区间为1，cost为0，右区间为3，4，cost为3，整个cost就是2+3=5。

当k为3时，左区间为1，2，cost为1，右区间为4，cost为0，整个cost就是3+1=4。

当k为4时，左区间1，2，3，cost为2，右区间为空，cost为0，整个cost就是4+2=6。
```



```python
import sys
class Solution(object):
    def getMoneyAmount(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp = [[0]*(n+1) for _ in range(n+1)]
        for i in range(1,n+1):
            for j in range(i-1,0,-1):
                # dp[j][i]表示j-i中猜出 任一 数字所需要的最少金额
                temp = sys.maxsize
                for k in range(j+1,i):
                    temp = min(temp,k+max(dp[j][k-1],dp[k+1][i]))
                if j+1==i:
                    dp[j][i] = j
                else:
                    dp[j][i] = temp
        return dp[1][n]
```

- 时间复杂度：$O(n^3)$
- 空间复杂度：$O(n^2)$ 