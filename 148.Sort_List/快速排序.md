## 快速排序

​	既然这道题提到了快速排序，那么这里正好对使用比较广泛的快排做一些总结。请先回忆一下冒泡排序，是如何通过“交换”，一步步让每个数归位的，冒泡是每轮从前往后扫描，如果第一个比第二个大（小），就交换他们两个，最后把最大的数沉到序列末尾。冒泡排序很浪费时间，每次都只能对相邻的两个数进行比较，这显然太不合理了。那么如何一步步交换呢？怎样交换才既方便又节省时间呢？那就需要我们的快速排序了，快排能够PK掉冒泡排序，那说明它确实是一个很好的排序算法，我们来看一下它的大致流程。

​	为了实现一次划分，我们可以从数组（假定数据是存在数组中）的两端移动下标，必要时交换记录，直到数组两端的下标相遇为止。为此，我们附设两个指针（下角标）i 和 j， 通过 j 从当前序列的有段向左扫描，越过不小于基准值的记录。当遇到小于基准值的记录时，扫描停止。通过 i  从当前序列的左端向右扫描，越过小于基准值的记录。当遇到不小于基准值的记录时，扫描停止。交换两个方向扫描停止的记录 a[j] 与 a[i]。  然后，继续扫描，直至 i 与 j 相遇为止。扫描和交换的过程结束。这是 i  左边的记录的关键字值都小于基准值，右边的记录的关键字值都不小于基准值。

​                         ![img](http://bbs.ahalei.com/data/attachment/forum/201402/25/232129ogop8gk0r8y7l70k.png)



为什么每次都要从后开始扫描呢？顺序是不能改变的，想一想：

 假设对如下进行排序：

​                                                         ![img](http://images0.cnblogs.com/blog/751746/201507/171952161265077.jpg)

如上图，6在左，9在右  我们将6作为基数。i从左边往右，j从右边往左。

假设从左边开始（与正确程序正好相反）

于是i 就会移动到现在的 数字 7 那个位置停下来，而  j 原来在 数字 9 那个位置 ，因为

于是，j 也会停留在数字7 那个位置，于是问题来了。当你最后交换基数6与7时，不对呀！！。

问题在于当我们先从在边开始时，那么 i 所停留的那个位置肯定是大于基数6的，而在上述例子中，为了满足 i<j 于是 j也停留在7的位置

但最后交换回去的时候，7就到了左边，不行，因为我们原本 交换后数字6在边应该是全部小于6，右边全部大于6.但现在不行了。

于是，我们必须从右边开始，也就是从基数的对面开始。



可以看一下python的快排，是不是感觉非常Pythonic～

```python
def quick_sort(array):
    left = []
    right = []
    if len(array) <=1:
        return array
    avg = array.pop()
    for x in array:
        if x >= avg:
            right.append(x)
        else:
            left.append(x)
    return quick_sort(left) + [avg] + quick_sort(right)
```

